<!-- /resources/components/entityTable.xhtml -->
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
                xmlns:p="http://primefaces.org/ui"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:cc="http://xmlns.jcp.org/jsf/composite">

    <cc:interface>

        <cc:attribute name="tableModel" required="true" type="fr.siamois.ui.table.EntityTableViewModel"/>
        <cc:attribute name="panelIndex" required="true" type="java.lang.Integer"/>
        <cc:attribute name="displayColumnToggler" required="false" default="false" type="java.lang.Boolean"/>
        <cc:attribute name="tableClass" required="false" default="siamois-unit-table" type="java.lang.String"/>

        <!-- Facettes de colonnes -->

        <cc:facet name="afterColumns"/>

        <!-- Facette toolbar droite, si besoin -->
        <cc:facet name="rightToolbar"/>
    </cc:interface>

    <cc:implementation>

        <p:dataTable paginator="true"
                     editable="true"
                     cellNavigation="true"
                     id="entityDatatable"
                     varStatus="status"
                     size="small"
                     paginatorPosition="bottom" var="item"
                     selectionPageOnly="false" selectionRowMode="none"
                     selection="#{cc.attrs.tableModel.lazyDataModel.selectedUnits}"
                     widgetVar="#{cc.clientId}_entityListTable"
                     lazy="true"
                     globalFilter="#{cc.attrs.lazyDataModel.globalFilter}"
                     allowUnsorting="true"
                     sortBy="#{cc.attrs.tableModel.lazyDataModel.sortBy}"
                     rows="#{cc.attrs.tableModel.lazyDataModel.pageSizeState}"
                     first="#{cc.attrs.tableModel.lazyDataModel.first}"
                     sortMode="multiple"
                     partialUpdate="false"
                     emptyMessage="#{langBean.msg('entityListTable.empty')}"
                     paginatorTemplate="Rows per page: {RowsPerPageDropdown} {RowReport} {FirstPageLink} {PreviousPageLink} {PageLinks} {NextPageLink} {LastPageLink}"
                     rowsPerPageTemplate="5,10,15,20,25"
                     rowIndexVar="rowIndex"
                     tableStyle="width:auto"
                     value="#{cc.attrs.tableModel.lazyDataModel}"
                     class="#{cc.attrs.tableClass}">

            <f:facet name="{RowReport}">
                        <span class="ui-paginator-current">#{cc.attrs.tableModel.lazyDataModel.getFirstIndexOnPage()}-#{cc.attrs.tableModel.lazyDataModel.getLastIndexOnPage()}
                            of #{cc.attrs.tableModel.lazyDataModel.rowCount}</span>
            </f:facet>

            <!-- Toolbar générique, globalFilter, toggler, bulk etc. -->
            <f:facet name="header">
                <p:toolbar>
                    <p:toolbarGroup align="left">
                        <!-- ici tu remets ton globalFilter, bulk, etc. -->
                    </p:toolbarGroup>
                    <p:toolbarGroup align="right">
                        <cc:renderFacet name="rightToolbar"/>
                    </p:toolbarGroup>
                </p:toolbar>
            </f:facet>

            <!-- Colonnes "custom" AVANT -->
            <cc:renderFacet name="beforeColumns"/>

            <!-- Colonnes dynamiques, basées sur tableDefinition -->
            <p:columns value="#{cc.attrs.tableModel.getColumns()}"
                       var="column"
                       varStatus="colStatus">

                <!-- Header -->
                <f:facet name="header">
                    #{langBean.msg(column.headerKey)}
                </f:facet>

                <!-- Contexte de formulaire pour cette ligne -->
                <ui:param name="rowContext"
                          value="#{cc.attrs.tableModel.getRowContext(item)}"/>

                <!-- Ici, 'column.field' est ton CustomField -->
                <!-- Si tu as aussi une CustomCol, tu peux la stocker dans TableColumn et l’utiliser ici -->

                <!-- Réutilisation du fragment de champ, mais en lui passant le bon 'bean' + 'answer' -->
                <ui:include src="/pages/shared/form/customFormFieldContentForTable.xhtml">
                    <ui:param name="bean" value="#{rowContext}"/>
                    <ui:param name="col" value="#{column}"/>
                    <ui:param name="prefix" value="table"/>
                    <ui:param name="statusIndex" value="#{status.index}"/>
                    <ui:param name="rowIndex" value="#{rowIndex}"/>
                    <ui:param name="colIndex" value="#{colStatus.index}"/>
                    <ui:param name="root" value="#{component.clientId}"/>
                    <ui:param name="panelIndex" value="0"/>

                    <!-- answer = réponse du EntityFormContext pour ce champ -->
                    <ui:param name="answer"
                              value="#{rowContext.getFieldAnswer(column.field)}"/>

                    <ui:param name="hasBeenModified"
                              value="#{answer != null and answer.hasBeenModified}"/>

                    <!-- génération auto : idem que dans les panels, si tu veux -->
                    <ui:param name="hasAutoGenerationFunction"
                              value="false"/>
                    <ui:param name="onGenerateValue"
                              value="#{null}"/>

                    <!-- callback onModified : ici tu peux pointer vers une méthode du lazyDataModel si besoin -->
                    <ui:param name="onModified"
                              value="#{null}"/>
                </ui:include>

            </p:columns>

            <!-- Colonnes "custom" APRÈS -->
            <cc:renderFacet name="afterColumns"/>

        </p:dataTable>

    </cc:implementation>
</ui:composition>
